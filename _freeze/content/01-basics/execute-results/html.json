{
  "hash": "b136b554d32130a0d354982bf1cae9cf",
  "result": {
    "markdown": "---\ntitle: \"Introduction to R: The Basics\"\nauthor: \"Rony Rodriguez-Ramirez\"\ndate: \"2024-02-01\"\n---\n\n\n\n\nWelcome to this introductory tutorial on R! R is a powerful language and environment for statistical computing and graphics. It offers a wide variety of statistical and graphical techniques and is highly extensible. One of the key features of R is its package ecosystem, the most notable of which is the tidyverse, a collection of packages designed for data science.\n\nThis tutorial is designed for individuals with minimal statistical background. We will cover the basics of R, including how to install and load packages, import data, perform simple data manipulations, and create basic visualizations.\n\n## Installing R and RStudio\n\nBefore we begin, you need to have R and RStudio installed on your computer. R is the underlying statistical computing environment, while RStudio provides a convenient and powerful user interface.\n\n1. Download R from [The Comprehensive R Archive Network (CRAN)](https://cran.r-project.org).\n2. Download RStudio from [RStudio's website](https://rstudio.com/products/rstudio/download/).\n\n## Getting Started\n\n### Setting Up Your Environment\n\nOpen RStudio and let's get started by installing and loading the tidyverse package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\nThe first line will install the package, and the second will load the package to your current R session. After you install your package, you do not need to use the first line again in your scripts.\n\n## Understanding Data Types in R\n\nR supports various data types, each serving different purposes in data analysis. Familiarity with these data types is essential for effective data manipulation. Below are the primary data types you'll encounter in R:\n\n### Numeric\n\nNumeric data types are used to represent real numbers. They can be integers (without decimal points) or doubles (with decimal points), though R treats all numbers as floating-point values by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_integer <- 42  # An integer\nmy_double  <- 42.5 # A double\n```\n:::\n\n\n### Character\n\nCharacter data types represent text. In R, text values are enclosed in quotes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_character <- \"Hello, world! I love econometrics!\"\nmy_character\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello, world! I love econometrics!\"\n```\n:::\n:::\n\n\n### Logical\n\nLogical (or boolean) data types represent TRUE or FALSE values. They are the result of conditions or logical operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_logical <- TRUE\nis_greater <- (5 > 2) # Evaluates to TRUE\n\nmy_logical\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_greater\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### Factor\n\nFactors are used to represent categorical data. They are especially useful for representing groups or levels (e.g., \"Low\", \"Medium\", \"High\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_factor <- factor(c(\"Low\", \"Medium\", \"High\", \"Low\", \"Medium\"))\n\nmy_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Low    Medium High   Low    Medium\nLevels: High Low Medium\n```\n:::\n:::\n\n\n### Date and POSIXct\n\nDate and POSIXct represent dates and date-times, respectively. They are crucial for time series analysis or any analysis that involves dates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_date     <- as.Date(\"2024-01-01\")\nmy_datetime <- as.POSIXct(\"2024-01-01 12:00:00\")\n\nmy_date\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2024-01-01\"\n```\n:::\n\n```{.r .cell-code}\nmy_datetime\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2024-01-01 12:00:00 EST\"\n```\n:::\n:::\n\n\n### List\n\nLists in R can contain elements of different types, including numbers, strings, vectors, and even other lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(name = \"Eric Taylor\", scores = c(90, 85, 88), passed = TRUE)\n```\n:::\n\n\nEach type has its specific purpose and a set of functions that operate on it, making it essential to choose the right type for your data analysis tasks.\n\n### Data Frame and Tibble\n\nA data frame is a table-like structure that can hold columns of different data types. A tibble is a modern take on the data frame, part of the `tidyverse`, designed to be more user-friendly. We will discuss more about this is the data cleaning section.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- data.frame(\n  id = 1:3,\n  name = c(\"Emma\", \"Rony\", \"Jostin\"),\n  score = c(90, 85, 88)\n)\n\nmy_tibble <- tibble(\n  id = 1:3,\n  name = c(\"Emma\", \"Rony\", \"Jostin\"),\n  score = c(90, 85, 88)\n)\n```\n:::\n\n\n### Basic R Operations\n\nNow, let's look at the basic operations. First, R can be used as a simple calculator. Try typing `2 + 2` in the console. You can assign values to variables using `<-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2 + 2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n### Vectors\n\nVectors are basic data structures in R that contain elements of the same type. Use the `c()` function to create a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, 2, 3, 4, 5)\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n\n## Importing Data\n\nR can read data from various sources. The `read_csv()` function from the readr package (part of the `tidyverse`) is commonly used for reading CSV files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- read_csv(\"path/to/your/file.csv\")\n```\n:::\n\n\nReplace \"path/to/your/file.csv\" with the actual file path to a csv file.\n\n## Data Manipulation with `dplyr`\n\nThe `dplyr` package offers a set of functions for manipulating data frames:\n\n- `filter()`: Extracts a subset of rows based on conditions.\n- `select()`: Selects columns by name.\n- `mutate()`: Creates new columns or modifies existing ones.\n- `summarize()`: Summarizes multiple values into a single value.\n\nHowever, before we use the dplyr package, let's understand the pipe operator.\n\n### Pipe operator\n\nThe pipe operator `%>%`, heavily used in tidyverse packages, allows you to pass the result of one expression as the first argument to the next expression. It's a powerful tool for chaining together a sequence of operations in a clear and concise manner. Instead of nesting functions or using intermediate variables, you can use the pipe operator to form a pipeline of operations.\n\n### How It Works\n\nConsider a simple example without the pipe operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- sum(c(1, 2, 3, 4, 5))\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nWith the pipe operator, the same operation looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4, 5) %>%\n  sum() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nAlthough this is a simplistic example, it illustrates how `%>%` passes the left-hand side of the operator as the first argument to the function on the right-hand side. This becomes particularly useful with functions from the `dplyr` package for data manipulation.\n\n### Practical Example with dplyr\n\nLet's revisit the dplyr package from earlier, now with an emphasis on understanding the pipe operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_data <- my_data_frame %>%\n  filter(score > 85) %>%\n  select(name, score)\n```\n:::\n\n\nIn this example:\n\n1. `my_data_frame` is passed as the first argument to the `filter()` function, which filters rows where score > 85.\n2. The result of `filter()` is then passed as the first argument to `select()`, which keeps only the columns name and score.\n3. The final result is assigned to `filtered_data`.\n\nBenefits of Using the Pipe Operator\n\n- **Readability**: The flow of operations is from left to right, similar to how we read text, making the code easier to follow.\n- **Maintainability**: It's easier to add or remove steps in the data processing pipeline without having to rewrite function calls or manage temporary variables.\n- **Clarity**: Each step in the pipeline can be clearly seen, making it easier to understand what each part of the code is doing.\n\nThe pipe operator is a cornerstone of the tidyverse approach to data manipulation, enabling clear and expressive code that closely resembles natural language. As you become more familiar with R and the tidyverse, you'll find the pipe operator indispensable for efficient data analysis and transformation.\n\n### Mutate, Summarize, and other Functions\n\nThe `mutate()` function allows you to create new columns in your data frame or change existing ones based on some operations or functions applied to the data. It's particularly useful for feature engineering, calculating new metrics, or preparing your data for analysis.\n\nLet's say we have a data frame `my_data_frame` that contains student IDs, names, and scores. We want to add a new column that shows whether each student passed based on their score, with a score of 85 or above considered a pass.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a new column 'passed' with boolean values: TRUE if score >= 85, FALSE otherwise\nmy_data_frame <- my_data_frame %>%\n  mutate(passed = score >= 85)\n\nmy_data_frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id   name score passed\n1  1   Emma    90   TRUE\n2  2   Rony    85   TRUE\n3  3 Jostin    88   TRUE\n```\n:::\n:::\n\n\nThis will add a new column passed to my_data_frame, where each row will have `TRUE` if the student's score is 85 or higher, and `FALSE` otherwise.\n\n#### Modifying Existing Columns\n\nYou can also use `mutate()` to modify existing columns. For example, suppose you want to standardize the scores (subtract the mean and divide by the standard deviation) for analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Standardize the 'score' column\nmy_data_frame <- my_data_frame %>%\n  mutate(\n    score_standardized = (score - mean(score)) / sd(score)\n  )\n\nmy_data_frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id   name score passed score_standardized\n1  1   Emma    90   TRUE          0.9271726\n2  2   Rony    85   TRUE         -1.0596259\n3  3 Jostin    88   TRUE          0.1324532\n```\n:::\n:::\n\n\nThis operation creates a new column `score_standardized` where each student's score is standardized.\n\n#### Using Multiple mutate() Operations\n\nYou can chain multiple operations within a single `mutate()` call. For example, if you wanted to add a column for the grade (A, B, C, etc.) based on the standardized score, you could do it within the same `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add a grade column based on standardized scores\nmy_data_frame <- my_data_frame %>%\n  mutate(\n    score_standardized = (score - mean(score)) / sd(score),\n    grade = case_when(\n      score_standardized >= 1  ~ \"A\",\n      score_standardized >= 0  ~ \"B\",\n      score_standardized < 0   ~ \"C\"\n    )\n  )\n\nmy_data_frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id   name score passed score_standardized grade\n1  1   Emma    90   TRUE          0.9271726     B\n2  2   Rony    85   TRUE         -1.0596259     C\n3  3 Jostin    88   TRUE          0.1324532     B\n```\n:::\n:::\n\n\nHere, `case_when()` is used to assign grades: \"A\" for standardized scores >= 1, \"B\" for scores >= 0 and < 1, and \"C\" for scores < 0. This illustrates how `mutate()` can be used to perform multiple transformations simultaneously, enhancing the readability and efficiency of your data manipulation code.\n\n## Summarizing Data with `summarize()`\n\nThe `summarize()` function in `dplyr` is used to create summary statistics for a dataset or subsets of a dataset. This function can be particularly powerful when combined with `group_by()`, which groups the data frame by one or more variables.\n\n### Basic Usage of `summarize()`\n\nHere's how you can use `summarize()` to calculate the average (mean) score of all students in `my_data_frame`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage_score <- my_data_frame %>%\n  summarize(\n    mean_score = mean(score)\n  )\n\naverage_score\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  mean_score\n1   87.66667\n```\n:::\n:::\n\n\nThis code calculates the mean of the `score` column and stores the result in a new data frame called `average_score` with a single column `mean_score`.\n\n### Grouped Summaries\n\nTo calculate the average score by a categorical variable (e.g., by a hypothetical `class` column), you first group the data by that variable using `group_by()`, then apply `summarize()`:\n\nFirst, let's add a hypothetical class variable to our data frame to categorize students into two classes, \"A\" and \"B\". We'll use the mutate() function to accomplish this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame <- my_data_frame %>%\n  mutate(\n    class = if_else(id %% 2 == 0, \"A\", \"B\")\n  )\n\nmy_data_frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id   name score passed score_standardized grade class\n1  1   Emma    90   TRUE          0.9271726     B     B\n2  2   Rony    85   TRUE         -1.0596259     C     A\n3  3 Jostin    88   TRUE          0.1324532     B     B\n```\n:::\n:::\n\n\nThis code adds a new column `class` to `my_data_frame`, where students with an even id are assigned to class \"A\" and students with an odd id are assigned to class \"B\".\n\nNow that we have a class variable, we can calculate the average score for each class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naverage_score_by_class <- my_data_frame %>%\n  group_by(class) %>%\n  summarize(mean_score = mean(score))\n\naverage_score_by_class\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  class mean_score\n  <chr>      <dbl>\n1 A             85\n2 B             89\n```\n:::\n:::\n\n\nThis will calculate the mean score for each class separately.\n\n### Multiple `summarize` Functions\n\nYou can also use `summarize()` to apply multiple summary functions at once. For example, to calculate the mean, median, and standard deviation of scores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_statistics <- my_data_frame %>%\n  summarize(\n    mean_score = mean(score),\n    median_score = median(score),\n    sd_score = sd(score)\n  )\n\nsummary_statistics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  mean_score median_score sd_score\n1   87.66667           88 2.516611\n```\n:::\n:::\n\n\n### Using `summarize()` with `mutate()`\n\nWhile `summarize()` reduces your data to a single summary row, `mutate()` can be used alongside to add summary columns to the original data frame. For example, adding a column with the mean score to each row:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_frame_with_mean <- my_data_frame %>%\n  mutate(mean_score = mean(score))\n\nmy_data_frame_with_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id   name score passed score_standardized grade class mean_score\n1  1   Emma    90   TRUE          0.9271726     B     B   87.66667\n2  2   Rony    85   TRUE         -1.0596259     C     A   87.66667\n3  3 Jostin    88   TRUE          0.1324532     B     B   87.66667\n```\n:::\n:::\n\n\n## Getting Help\n\nIf you don't understand a function, you can use the question mark and the function you would like to know more about, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mutate()\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}