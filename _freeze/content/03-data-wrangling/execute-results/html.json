{
  "hash": "c97cc5fe503dc49ba22a0985269d13ed",
  "result": {
    "markdown": "---\ntitle: \"Data Wrangling\"\nauthor: \"Rony Rodriguez-Ramirez\"\ndate: \"2024-02-02\"\n---\n\n\n\n\n\n## Introduction\n\nIn this tutorial, we delve into advanced data cleaning and analysis techniques focusing on student and department datasets. We will also demonstrate how to create custom functions in R to automate repetitive tasks in data analysis. We will delve into more sophisticated techniques such as reshaping data with `pivot_wider` and `pivot_longer`, and enhancing our data transformation skills with `mutate` across and the creation of custom functions. These methods are pivotal for preparing and analyzing data more effectively.\n\n## Reshaping Data\n\nReshaping data is a common task in data analysis that involves changing the structure of your data to make it more suitable for analysis. `tidyverse` provides two primary functions for this purpose: `pivot_longer` and `pivot_wider`.\n\n### Using `pivot_longer`\n\nWhen you have data in a wide format and want to make it longer, `pivot_longer` is your go-to function. It's especially useful for converting multiple columns into key-value pairs, making the data tidy.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sample wide data\nwide_data <- tibble(\n  id = 1:3,\n  year_2018 = c(200, 150, 120),\n  year_2019 = c(220, 160, 130)\n)\n\n# Converting wide data to long format\nlong_data <- wide_data %>%\n  pivot_longer(\n    cols = starts_with(\"year\"),\n    names_to = \"year\",\n    values_to = \"value\"\n  )\nlong_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n     id year      value\n  <int> <chr>     <dbl>\n1     1 year_2018   200\n2     1 year_2019   220\n3     2 year_2018   150\n4     2 year_2019   160\n5     3 year_2018   120\n6     3 year_2019   130\n```\n:::\n:::\n\n\n### Using `pivot_wider`\n\nConversely, `pivot_wider` is used to spread a key-value pair across multiple columns, transforming longer data into a wider format. This is particularly useful for making data more readable or preparing it for certain types of analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Converting back to wide format\nwider_data <- long_data %>%\n  pivot_wider(\n    names_from = year,\n    values_from = value\n  )\n\nwider_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n     id year_2018 year_2019\n  <int>     <dbl>     <dbl>\n1     1       200       220\n2     2       150       160\n3     3       120       130\n```\n:::\n:::\n\n\n## Enhancing Data Transformation with `mutate` and Custom Functions\n\n### Using `mutate` and `across`\n\nWith `mutate` `across`, you can apply a function across multiple columns at once, streamlining the process of data manipulation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Applying a transformation across selected columns\ndata <- tibble(\n  x1 = rnorm(5),\n  x2 = rnorm(5),\n  x3 = rnorm(5)\n)\n\n# Standardizing selected columns\ndata <- data %>%\n  mutate(\n    across(\n      starts_with(\"x\"), \n      ~(.x - mean(.x)) / sd(.x),\n      .names = \"std_{.col}\"\n    )\n  )\n```\n:::\n\n\n1. **`mutate()`**: This function is used to add new columns or transform existing ones in a dataframe. Here, it is combined with the `across()` function to apply a transformation across multiple columns.\n   \n2. **`across(starts_with(\"x\"), ~(x. - mean(.x)) / sd(.x))`**: The `across()` function specifies which columns to operate on and the operation to perform:\n   \n   - **`starts_with(\"x\")`**: This argument selects all columns whose names start with \"x\".\n   \n   - **`~(.x - mean(.x)) / sd(.x)`**: This formula calculates the z-score for each selected column. For each value in a column, it subtracts the mean of that column and then divides by the standard deviation of that column. The `.` symbol represents the current column's values being processed.\n   - The `.names = \"std_{.col}\"` argument in the `across()` function dynamically names new or transformed columns as `std_` followed by the original column name, indicating they have been standardized.\n   \nEssentially, the code standardizes the values of all columns in `data` that start with the letter \"x\", ensuring they have a mean of 0 and a standard deviation of 1, then updates `data` with these standardized columns. \n\n\n## Creating Functions for Data Analysis\n\nCreating custom functions can significantly enhance efficiency in data analysis. It might not be the case, but if you want to have a function that estimates the `mean`, `sd`, and `std` value in a column we can do the following. Let's called it `add_stats_columns`. This function is designed to enhance a dataset by adding statistical analysis columns related to a specific numeric column within the dataset. It calculates the mean, standard deviation, and creates a standardized version of the selected column. Below is an explanation of the function and a breakdown of each line within it:\n\n### The `add_stats_columns` Function Explained\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_stats_columns <- function(data, column_name) {\n  mean_val <- mean(data[[column_name]], na.rm = TRUE)\n  sd_val   <- sd(data[[column_name]], na.rm = TRUE)\n  \n  data[[paste0(column_name, \"_mean\")]] <- mean_val\n  data[[paste0(column_name, \"_sd\")]]   <- sd_val\n  data[[paste0(column_name, \"_standardized\")]] <- (data[[column_name]] - mean_val) / sd_val\n  \n  return(data)\n}\n```\n:::\n\n\n#### Breaking Down the Function\n\n- `add_stats_columns <- function(data, column_name) { ... }`: This line defines the function `add_stats_columns` that takes two arguments: `data`, a dataset (in the form of a data frame or tibble), and `column_name`, a string representing the name of the column to be analyzed.\n- `mean_val <- mean(data[[column_name]], na.rm = TRUE)`: This line calculates the mean of the specified column, excluding any `NA` (missing) values with `na.rm = TRUE`, and stores it in `mean_val`.\n- `sd_val <- sd(data[[column_name]], na.rm = TRUE)`: Similarly, this line calculates the standard deviation of the specified column, excluding `NA` values, and stores it in `sd_val`.\n- `data[[paste0(column_name, \"_mean\")]] <- mean_val`: This line creates a new column in the dataset named after the original column with `_mean` appended (e.g., if `column_name` is `\"scores\"`, the new column name will be `\"scores_mean\"`), and assigns the calculated mean value to this new column for all rows.\n- `data[[paste0(column_name, \"_sd\")]] <- sd_val`: This line adds another new column to the dataset for the standard deviation, following the same naming convention as for the mean (e.g., `\"scores_sd\"`), and fills it with the calculated standard deviation value.\n- `data[[paste0(column_name, \"_standardized\")]] <- (data[[column_name]] - mean_val) / sd_val`: This line calculates the standardized value for each row in the specified column by subtracting the mean and dividing by the standard deviation. It then stores these values in a new column named with `_standardized` appended to the original column name (e.g., `\"scores_standardized\"`). Standardizing a dataset in this way adjusts the values to have a mean of 0 and a standard deviation of 1, which is useful for certain types of analysis and modeling.\n- `return(data)`: Finally, the function returns the modified dataset with the new statistical columns added. In fact, you can just write `data`, do not need to use the `return` function but let's keep it.\n\n### Usage Example\n\nAssuming `students` is a dataset with a numeric column named `\"math_scores\"`, you can use the function to add statistical analysis columns related to `\"math_scores\"` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example usage with a hypothetical numeric column in students dataset\n\n# Students data\nstudents <- tibble(\n  stu_id = c(1, 2, 3, 4),\n  stu_name = c(\"Emma\", \"Rony\", \"Jostin\", \"David\"),\n  dept_id = c(2, 2, 3, 4)\n)\n\n# Let's merge a math_scores data first.\nscores <- tibble(\n  stu_id = c(1, 2, 3, 4),\n  math_scores = c(80, 95, 93, 90)\n)\n\n# Merge the scores with the students data using stu_id \nstu_scores <- right_join(students, scores, by = \"stu_id\")\nstu_scores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  stu_id stu_name dept_id math_scores\n   <dbl> <chr>      <dbl>       <dbl>\n1      1 Emma           2          80\n2      2 Rony           2          95\n3      3 Jostin         3          93\n4      4 David          4          90\n```\n:::\n\n```{.r .cell-code}\n# Now, let's apply the function add_stats_columns\nstu_scores_with_stats <- add_stats_columns(stu_scores, \"math_scores\")\nstu_scores_with_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 7\n  stu_id stu_name dept_id math_scores math_scores_mean math_scores_sd\n   <dbl> <chr>      <dbl>       <dbl>            <dbl>          <dbl>\n1      1 Emma           2          80             89.5           6.66\n2      2 Rony           2          95             89.5           6.66\n3      3 Jostin         3          93             89.5           6.66\n4      4 David          4          90             89.5           6.66\n# ℹ 1 more variable: math_scores_standardized <dbl>\n```\n:::\n:::\n\n\n### Applying Functions to Grouped Data\n\nUsing `dplyr` and `purrr` to apply functions to each group separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group by department and apply stats function\nstudents_grouped <- stu_scores %>%\n  group_by(dept_id) %>%\n  group_modify(~ add_stats_columns(.x, \"math_scores\")) %>%\n  ungroup()\n\nstudents_grouped\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 7\n  dept_id stu_id stu_name math_scores math_scores_mean math_scores_sd\n    <dbl>  <dbl> <chr>          <dbl>            <dbl>          <dbl>\n1       2      1 Emma              80             87.5           10.6\n2       2      2 Rony              95             87.5           10.6\n3       3      3 Jostin            93             93             NA  \n4       4      4 David             90             90             NA  \n# ℹ 1 more variable: math_scores_standardized <dbl>\n```\n:::\n:::\n\n\n`group_modify()` applies a function to each group of a grouped dataframe, where `.x` is the sliced dataframe for each group. This way, the add_stats_columns function is applied correctly to each department group within your `stu_scores` dataset.\n\nThis corrected approach ensures that your custom function `add_stats_columns` is applied to the math_scores column for each group defined by `dept_id`, achieving the intended goal of adding statistical columns based on department groups.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}