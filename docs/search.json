[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to Intro to R for PhD Students in Education",
    "section": "",
    "text": "Hello, I’m Rony Rodriguez-Ramirez, and this website is my personal project to provide PhD students in Education with tutorials, resources, and tools aimed at enhancing their research and academic skills. This initiative is designed to support your journey through the PhD program with practical and accessible learning materials."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "content/01-basics.html",
    "href": "content/01-basics.html",
    "title": "Introduction to R: The Basics",
    "section": "",
    "text": "Welcome to this introductory tutorial on R! R is a powerful language and environment for statistical computing and graphics. It offers a wide variety of statistical and graphical techniques and is highly extensible. One of the key features of R is its package ecosystem, the most notable of which is the tidyverse, a collection of packages designed for data science.\nThis tutorial is designed for individuals with minimal statistical background. We will cover the basics of R, including how to install and load packages, import data, perform simple data manipulations, and create basic visualizations."
  },
  {
    "objectID": "content/01-basics.html#installing-r-and-rstudio",
    "href": "content/01-basics.html#installing-r-and-rstudio",
    "title": "Introduction to R: The Basics",
    "section": "Installing R and RStudio",
    "text": "Installing R and RStudio\nBefore we begin, you need to have R and RStudio installed on your computer. R is the underlying statistical computing environment, while RStudio provides a convenient and powerful user interface.\n\nDownload R from The Comprehensive R Archive Network (CRAN).\nDownload RStudio from RStudio’s website."
  },
  {
    "objectID": "content/01-basics.html#getting-started",
    "href": "content/01-basics.html#getting-started",
    "title": "Introduction to R: The Basics",
    "section": "Getting Started",
    "text": "Getting Started\n\nSetting Up Your Environment\nOpen RStudio and let’s get started by installing and loading the tidyverse package:\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nThe first line will install the package, and the second will load the package to your current R session. After you install your package, you do not need to use the first line again in your scripts."
  },
  {
    "objectID": "content/01-basics.html#basic-r-operations",
    "href": "content/01-basics.html#basic-r-operations",
    "title": "Introduction to R: The Basics",
    "section": "Basic R Operations",
    "text": "Basic R Operations\nNow, let’s look at the basic operations. First, R can be used as a simple calculator. Try typing 2 + 2 in the console. You can assign values to variables using &lt;-.\n\nx &lt;- 2 + 2\nx\n\n[1] 4"
  },
  {
    "objectID": "content/01-basics.html#vectors-and-data-frames",
    "href": "content/01-basics.html#vectors-and-data-frames",
    "title": "Introduction to R: The Basics",
    "section": "Vectors and Data Frames",
    "text": "Vectors and Data Frames\nVectors are basic data structures in R that contain elements of the same type. Use the c() function to create a vector:\n\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nmy_vector\n\n[1] 1 2 3 4 5\n\n\nA data frame is a table or a two-dimensional array-like structure. Let’s create a simple data frame:\n\nmy_data_frame &lt;- data.frame(\n  id = 1:5,\n  name = c(\"Emma\", \"Rony\", \"Jostin\", \"David\", \"Alex\"),\n  score = c(90, 80, 88, 100, 100)\n)\n\nmy_data_frame\n\n  id   name score\n1  1   Emma    90\n2  2   Rony    80\n3  3 Jostin    88\n4  4  David   100\n5  5   Alex   100"
  },
  {
    "objectID": "content/01-basics.html#importing-data",
    "href": "content/01-basics.html#importing-data",
    "title": "Introduction to R: The Basics",
    "section": "Importing Data",
    "text": "Importing Data\nR can read data from various sources. The read_csv() function from the readr package (part of the tidyverse) is commonly used for reading CSV files:\n\nmy_data &lt;- read_csv(\"path/to/your/file.csv\")\n\nReplace “path/to/your/file.csv” with the actual file path to a csv file."
  },
  {
    "objectID": "content/01-basics.html#data-manipulation-with-dplyr",
    "href": "content/01-basics.html#data-manipulation-with-dplyr",
    "title": "Introduction to R: The Basics",
    "section": "Data Manipulation with dplyr",
    "text": "Data Manipulation with dplyr\nThe dplyr package offers a set of functions for manipulating data frames:\n\nfilter(): Extracts a subset of rows based on conditions.\nselect(): Selects columns by name.\nmutate(): Creates new columns or modifies existing ones.\nsummarise(): Summarizes multiple values into a single value.\n\nHowever, before we use the dplyr package, let’s understand the pipe operator.\n\nPipe operator\nThe pipe operator %&gt;%, heavily used in tidyverse packages, allows you to pass the result of one expression as the first argument to the next expression. It’s a powerful tool for chaining together a sequence of operations in a clear and concise manner. Instead of nesting functions or using intermediate variables, you can use the pipe operator to form a pipeline of operations.\n\n\nHow It Works\nConsider a simple example without the pipe operator:\n\nresult &lt;- sum(c(1, 2, 3, 4, 5))\nresult\n\n[1] 15\n\n\nWith the pipe operator, the same operation looks like this:\n\nc(1, 2, 3, 4, 5) %&gt;%\n  sum() \n\n[1] 15\n\n\nAlthough this is a simplistic example, it illustrates how %&gt;% passes the left-hand side of the operator as the first argument to the function on the right-hand side. This becomes particularly useful with functions from the dplyr package for data manipulation.\n\n\nPractical Example with dplyr\nLet’s revisit the dplyr package from earlier, now with an emphasis on understanding the pipe operator:\n\nfiltered_data &lt;- my_data_frame %&gt;%\n  filter(score &gt; 85) %&gt;%\n  select(name, score)\n\nIn this example:\n\nmy_data_frame is passed as the first argument to the filter() function, which filters rows where score &gt; 85.\nThe result of filter() is then passed as the first argument to select(), which keeps only the columns name and score.\nThe final result is assigned to filtered_data.\n\nBenefits of Using the Pipe Operator\n\nReadability: The flow of operations is from left to right, similar to how we read text, making the code easier to follow.\nMaintainability: It’s easier to add or remove steps in the data processing pipeline without having to rewrite function calls or manage temporary variables.\nClarity: Each step in the pipeline can be clearly seen, making it easier to understand what each part of the code is doing.\n\nThe pipe operator is a cornerstone of the tidyverse approach to data manipulation, enabling clear and expressive code that closely resembles natural language. As you become more familiar with R and the tidyverse, you’ll find the pipe operator indispensable for efficient data analysis and transformation.\n\n\nMutate, Summarize, and other Functions\nThe mutate() function allows you to create new columns in your data frame or change existing ones based on some operations or functions applied to the data. It’s particularly useful for feature engineering, calculating new metrics, or preparing your data for analysis.\nLet’s say we have a data frame my_data_frame that contains student IDs, names, and scores. We want to add a new column that shows whether each student passed based on their score, with a score of 85 or above considered a pass.\n\n# Add a new column 'passed' with boolean values: TRUE if score &gt;= 85, FALSE otherwise\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(passed = score &gt;= 85)\n\nmy_data_frame\n\n  id   name score passed\n1  1   Emma    90   TRUE\n2  2   Rony    80  FALSE\n3  3 Jostin    88   TRUE\n4  4  David   100   TRUE\n5  5   Alex   100   TRUE\n\n\nThis will add a new column passed to my_data_frame, where each row will have TRUE if the student’s score is 85 or higher, and FALSE otherwise.\n\nModifying Existing Columns\nYou can also use mutate() to modify existing columns. For example, suppose you want to standardize the scores (subtract the mean and divide by the standard deviation) for analysis.\n\n# Standardize the 'score' column\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(score_standardized = (score - mean(score)) / sd(score))\n\nmy_data_frame\n\n  id   name score passed score_standardized\n1  1   Emma    90   TRUE         -0.1875229\n2  2   Rony    80  FALSE         -1.3595410\n3  3 Jostin    88   TRUE         -0.4219265\n4  4  David   100   TRUE          0.9844952\n5  5   Alex   100   TRUE          0.9844952\n\n\nThis operation creates a new column score_standardized where each student’s score is standardized.\n\n\nUsing Multiple mutate() Operations\nYou can chain multiple operations within a single mutate() call. For example, if you wanted to add a column for the grade (A, B, C, etc.) based on the standardized score, you could do it within the same mutate():\n\n# Add a grade column based on standardized scores\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(\n    score_standardized = (score - mean(score)) / sd(score),\n    grade = case_when(\n      score_standardized &gt;= 1  ~ \"A\",\n      score_standardized &gt;= 0  ~ \"B\",\n      score_standardized &lt; 0   ~ \"C\"\n    )\n  )\n\nmy_data_frame\n\n  id   name score passed score_standardized grade\n1  1   Emma    90   TRUE         -0.1875229     C\n2  2   Rony    80  FALSE         -1.3595410     C\n3  3 Jostin    88   TRUE         -0.4219265     C\n4  4  David   100   TRUE          0.9844952     B\n5  5   Alex   100   TRUE          0.9844952     B\n\n\nIn this example, case_when() is used to assign grades: “A” for standardized scores &gt;= 1, “B” for scores &gt;= 0 and &lt; 1, and “C” for scores &lt; 0. This illustrates how mutate() can be used to perform multiple transformations simultaneously, enhancing the readability and efficiency of your data manipulation code."
  },
  {
    "objectID": "content/01-basics.html#summarizing-data-with-summarise",
    "href": "content/01-basics.html#summarizing-data-with-summarise",
    "title": "Introduction to R: The Basics",
    "section": "Summarizing Data with summarise()",
    "text": "Summarizing Data with summarise()\nThe summarise() function in dplyr is used to create summary statistics for a dataset or subsets of a dataset. This function can be particularly powerful when combined with group_by(), which groups the data frame by one or more variables.\n\nBasic Usage of summarise()\nHere’s how you can use summarise() to calculate the average (mean) score of all students in my_data_frame:\n\naverage_score &lt;- my_data_frame %&gt;%\n  summarise(mean_score = mean(score))\n\naverage_score\n\n  mean_score\n1       91.6\n\n\nThis code calculates the mean of the score column and stores the result in a new data frame called average_score with a single column mean_score.\n\n\nGrouped Summaries\nTo calculate the average score by a categorical variable (e.g., by a hypothetical class column), you first group the data by that variable using group_by(), then apply summarise():\nFirst, let’s add a hypothetical class variable to our data frame to categorize students into two classes, “A” and “B”. We’ll use the mutate() function to accomplish this:\n\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(class = if_else(id %% 2 == 0, \"A\", \"B\"))\n\nmy_data_frame\n\n  id   name score passed score_standardized grade class\n1  1   Emma    90   TRUE         -0.1875229     C     B\n2  2   Rony    80  FALSE         -1.3595410     C     A\n3  3 Jostin    88   TRUE         -0.4219265     C     B\n4  4  David   100   TRUE          0.9844952     B     A\n5  5   Alex   100   TRUE          0.9844952     B     B\n\n\nThis code adds a new column class to my_data_frame, where students with an even id are assigned to class “A” and students with an odd id are assigned to class “B”.\nNow that we have a class variable, we can calculate the average score for each class:\n\naverage_score_by_class &lt;- my_data_frame %&gt;%\n  group_by(class) %&gt;%\n  summarise(mean_score = mean(score))\n\naverage_score_by_class\n\n# A tibble: 2 × 2\n  class mean_score\n  &lt;chr&gt;      &lt;dbl&gt;\n1 A           90  \n2 B           92.7\n\n\nThis will calculate the mean score for each class separately.\n\n\nMultiple Summary Functions\nYou can also use summarise() to apply multiple summary functions at once. For example, to calculate the mean, median, and standard deviation of scores:\n\nsummary_statistics &lt;- my_data_frame %&gt;%\n  summarise(\n    mean_score = mean(score),\n    median_score = median(score),\n    sd_score = sd(score)\n  )\n\nsummary_statistics\n\n  mean_score median_score sd_score\n1       91.6           90 8.532292\n\n\n\n\nUsing summarise() with mutate()\nWhile summarise() reduces your data to a single summary row, mutate() can be used alongside to add summary columns to the original data frame. For example, adding a column with the mean score to each row:\n\nmy_data_frame_with_mean &lt;- my_data_frame %&gt;%\n  mutate(mean_score = mean(score))\n\nmy_data_frame_with_mean\n\n  id   name score passed score_standardized grade class mean_score\n1  1   Emma    90   TRUE         -0.1875229     C     B       91.6\n2  2   Rony    80  FALSE         -1.3595410     C     A       91.6\n3  3 Jostin    88   TRUE         -0.4219265     C     B       91.6\n4  4  David   100   TRUE          0.9844952     B     A       91.6\n5  5   Alex   100   TRUE          0.9844952     B     B       91.6"
  },
  {
    "objectID": "content/01-basics.html#data-visualization-with-ggplot2",
    "href": "content/01-basics.html#data-visualization-with-ggplot2",
    "title": "Introduction to R: The Basics",
    "section": "Data Visualization with ggplot2",
    "text": "Data Visualization with ggplot2\nggplot2 is a part of the tidyverse that allows for creating complex and beautiful visualizations using a consistent and intuitive syntax. The name ggplot2 is derived from the concept of the grammar of graphics, a system for describing and building a wide range of graphics.\n\nBasics of ggplot2\nA ggplot2 graph is built up from a few basic elements:\n\nData: The dataset you want to visualize.\nAesthetics (aes): Defines how variables in the data are mapped to visual properties (aesthetics) of the graph such as x and y axes, color, size, etc.\nGeometries (geom_ functions): The geometric objects (shapes) that represent the data points. For example, points (geom_point() for scatter plots), lines (geom_line()), and bars (geom_bar() for bar charts).\n\n\n\nCreating a Scatter Plot\nLet’s create a simple scatter plot to visualize the relationship between two variables in my_data_frame.\n\nggplot(my_data_frame, aes(x = id, y = score)) +\n  geom_point()\n\n\n\n\nIn this example, ggplot() initializes the plot with the data frame my_data_frame, and aes(x = id, y = score) specifies that id should be on the x-axis and score on the y-axis. geom_point() adds points to represent each row in the dataset.\n\n\nCustomizing Your Plot\nggplot2 offers extensive customization options. For example, you can add titles and labels, change the theme, and modify the color of the points.\n\nggplot(my_data_frame, aes(x = id, y = score)) +\n  geom_point(color = \"blue\") +\n  labs(title = \"Student Scores\", x = \"ID\", y = \"Score\") +\n  theme_minimal()\n\n\n\n\nThis adds a title to the plot, labels the x and y axes, changes the point color to blue, and applies a minimal theme for a cleaner look.\n\n\nCreating a Bar Chart\nTo create a bar chart showing students by score, you can use geom_col().\n\nggplot(my_data_frame, aes(y = score, x = as.factor(name))) +\n  geom_col(color = \"black\", fill = \"grey\") +\n  labs(title = \"Students by Score\", x = NULL, y = \"Score\") +\n  theme_minimal()\n\n\n\n\nHere, as.factor(name) is used to treat the name variable as a categorical variable. geom_bar() by default counts the number of occurrences of each unique value.\nggplot2 is a versatile and powerful tool for creating visualizations in R. With its consistent syntax and comprehensive features, it allows you to construct a wide variety of graph types, from simple scatter plots to complex multi-layered graphics. As you become more familiar with ggplot2, you will discover its full potential for conveying information in a visual format.\nCertainly! Let’s add a section on the summarise() function from the dplyr package. summarise() is used to reduce each group of a data frame to a single summary value, making it essential for data analysis tasks such as calculating summaries (mean, median, sum, etc.) across groups."
  },
  {
    "objectID": "index.html#about-this-project",
    "href": "index.html#about-this-project",
    "title": "Welcome to Intro to R for PhD Students in Education",
    "section": "About This Project",
    "text": "About This Project\nThis project is a work in progress, and I am constantly looking to update and improve the content. I welcome any suggestions, feedback, or contributions you might have."
  },
  {
    "objectID": "index.html#tutorials",
    "href": "index.html#tutorials",
    "title": "Welcome to Intro to R for PhD Students in Education",
    "section": "Tutorials",
    "text": "Tutorials\nI’ve crafted these tutorials to cater to a broad spectrum of needs, from the basics of statistical analysis using R, to more nuanced discussions on quantitative research methodologies. Here are a few highlights:\n\nTo complete"
  },
  {
    "objectID": "index.html#additional-resources",
    "href": "index.html#additional-resources",
    "title": "Welcome to Intro to R for PhD Students in Education",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nTo complete\n\nThank you for visiting, and I hope you find these resources helpful on your academic path!\n\n\n© 2024 Rony Rodriguez-Ramirez"
  },
  {
    "objectID": "index.html#lets-collaborate",
    "href": "index.html#lets-collaborate",
    "title": "Welcome Intro to R for PhD Students in Education",
    "section": "Let’s Collaborate",
    "text": "Let’s Collaborate\nI am the sole author and creator behind this project, and it is a labor of love. I am always open to suggestions for new content, improvements to existing materials, or any other feedback you might have. If you’d like to contribute or share your thoughts, please feel free to contact me.\nThank you for visiting, and I hope you find these resources helpful on your academic path!\n\n\n© 2024 Rony Rodriguez-Ramirez"
  },
  {
    "objectID": "content/index.html",
    "href": "content/index.html",
    "title": "Readings, lectures, and videos",
    "section": "",
    "text": "Each tutorial has a set of required readings that you should complete before watching the lecture."
  },
  {
    "objectID": "content/02-data-cleaning.html",
    "href": "content/02-data-cleaning.html",
    "title": "Data Cleaning and Analysis with tidyverse: First Part",
    "section": "",
    "text": "Building on the basics of R and the tidyverse, this tutorial delves into more complex data cleaning and analysis techniques. We’ll tackle common challenges encountered with real-world data and explore ways to manipulate and analyze datasets to extract meaningful insights."
  },
  {
    "objectID": "content/02-data-cleaning.html#handling-missing-data",
    "href": "content/02-data-cleaning.html#handling-missing-data",
    "title": "Data Cleaning and Analysis with tidyverse: First Part",
    "section": "Handling Missing Data",
    "text": "Handling Missing Data\nReal-world datasets often come with missing values, which can significantly impact your analysis. Let’s explore strategies to deal with missing data:\n\nIdentifying Missing Values\nIn the tidyverse, tibble() and tribble() are functions that create a more modern take on the data frame. They are part of the tibble package and offer several advantages over the base R data.frame for data analysis and manipulation (the one we saw in the basics tutorial. Here’s a brief overview of each and how they compare to traditional data frames.\n\n\ntibble()\nA tibble is a modern reimagining of the data frame, keeping what time has proven to be effective, and throwing out what is not. Here are some key features:\n\nPrinting: Tibbles are printed in a more readable format than traditional data frames, showing only the first 10 rows and all columns that fit on the screen.\nSubsetting: Subsetting a tibble with [ always returns a tibble, unlike data.frame, which might return a vector if a single column is selected.\nColumn data types: Tibbles are more tolerant about column types and do not convert strings to factors by default (a common source of frustration in R).\n\n\n# Creating a tibble\nmy_tibble &lt;- tibble(\n  id = 1:5,\n  name = c(\"Emma\", \"Rony\", \"Jostin\", \"David\", \"Alex\"),\n  score = c(90, 85, 88, 95, 80)\n)\n\n\n\ntribble()\ntribble(), short for “transposed tibble”, is designed for easy manual creation of tibbles. It allows for a column-wise specification of data which can be more readable and convenient for small datasets or examples.\n\nReadability: The layout of tribble() makes it easy to visually match values to their respective columns.\nConvenience: Ideal for creating small datasets for examples or tests.\n\n\n# Creating a tribble\nmy_tribble &lt;- tribble(\n  ~id, ~name,    ~score,\n  1,   \"Emma\",  90,\n  2,   \"Rony\",  85,\n  3,   \"Jostin\", 88,\n  4,   \"David\",  95,\n  5,   \"Alex\",    80\n)\n\n\n\nDifferences from data.frame\nWhile data.frame is the base R structure for storing tabular data, tibble and tribble bring improvements that are particularly useful in data analysis:\n\nPrinting and Viewing: Tibbles provide a more user-friendly way to view data in the console.\nFactor conversion: By default, strings are not converted to factors in tibbles, avoiding unexpected behavior during data analysis.\nSubsetting behavior: Consistent output types make tibble subsetting more predictable.\nRow names: Tibbles do not use row names, which encourages cleaner, more explicit data manipulation.\n\nIn summary, tibble() and tribble() offer a modern, tidyverse-optimized approach to data frames, making data manipulation and exploration in R more intuitive and less prone to common data analysis pitfalls.\nLet’s go back to our data cleaning tutorial and let’s first create a dataset with missing values:\n\n# Load sample data\ndata &lt;- tribble(\n  ~id, ~value, ~category,\n  1, NA, \"A\",\n  2, 5, \"B\",\n  3, 2, \"A\",\n  4, NA, \"B\",\n  5, 3, \"C\"\n)\n\n# Identify rows with missing values\ndata %&gt;% \n  filter(is.na(value))\n\n# A tibble: 2 × 3\n     id value category\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   \n1     1    NA A       \n2     4    NA B       \n\n\n\n\nImputing Missing Values\n\n# Impute missing values with the mean\ndata %&gt;% \n  mutate(\n    value = if_else(is.na(value), mean(value, na.rm = TRUE), value)\n  )\n\n# A tibble: 5 × 3\n     id value category\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   \n1     1  3.33 A       \n2     2  5    B       \n3     3  2    A       \n4     4  3.33 B       \n5     5  3    C"
  },
  {
    "objectID": "content/02-data-cleaning.html#joining-datasets",
    "href": "content/02-data-cleaning.html#joining-datasets",
    "title": "Data Cleaning and Analysis with tidyverse: First Part",
    "section": "Joining Datasets",
    "text": "Joining Datasets\nOften, you’ll need to combine data from multiple sources. Here, we’ll use dplyr’s join functions to merge datasets.\n\nExample Datasets\n\n# Create two sample datasets\nstudents &lt;- tibble(\n  id = 1:3,\n  name = c(\"Emma\", \"Rony\", \"Jostin\")\n)\n\nscores &lt;- tibble(\n  id = c(1, 2, 4),\n  score = c(88, 95, 75)\n)\n\n\n\nInner Join\n\n# Merge datasets to include only matching IDs\ninner_join(students, scores, by = \"id\")\n\n# A tibble: 2 × 3\n     id name  score\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Emma     88\n2     2 Rony     95"
  },
  {
    "objectID": "content/02-data-cleaning.html#exploratory-data-analysis-eda",
    "href": "content/02-data-cleaning.html#exploratory-data-analysis-eda",
    "title": "Data Cleaning and Analysis with tidyverse: First Part",
    "section": "Exploratory Data Analysis (EDA)",
    "text": "Exploratory Data Analysis (EDA)\nEDA is crucial for understanding the underlying patterns of your data. We’ll use ggplot2 for visualization.\n\nHistograms\nHistograms are great for visualizing the distribution of a numerical variable:\n\n# Using the `scores` dataset\nggplot(scores, aes(x = score)) +\n  geom_histogram(bins = 5, fill = \"grey\", color = \"black\") +\n  labs(title = \"Distribution of Scores\") +\n  theme_minimal()\n\n\n\n\n\n\nBoxplots\nBoxplots provide insights into the central tendency and spread of data, as well as outliers:\n\n# Using the `scores` dataset\nggplot(scores, aes(x = \"\", y = score)) +\n  geom_boxplot(fill = \"grey\", color = \"black\") +\n  labs(title = \"Score Spread\") +\n  theme_minimal()"
  },
  {
    "objectID": "content/01-basics.html#understanding-data-types-in-r",
    "href": "content/01-basics.html#understanding-data-types-in-r",
    "title": "Introduction to R: The Basics",
    "section": "Understanding Data Types in R",
    "text": "Understanding Data Types in R\nR supports various data types, each serving different purposes in data analysis. Familiarity with these data types is essential for effective data manipulation. Below are the primary data types you’ll encounter in R:\n\nNumeric\nNumeric data types are used to represent real numbers. They can be integers (without decimal points) or doubles (with decimal points), though R treats all numbers as floating-point values by default.\n\nmy_integer &lt;- 42  # An integer\nmy_double  &lt;- 42.5 # A double\n\n\n\nCharacter\nCharacter data types represent text. In R, text values are enclosed in quotes.\n\nmy_character &lt;- \"Hello, world! I love econometrics!\"\nmy_character\n\n[1] \"Hello, world! I love econometrics!\"\n\n\n\n\nLogical\nLogical (or boolean) data types represent TRUE or FALSE values. They are the result of conditions or logical operations.\n\nmy_logical &lt;- TRUE\nis_greater &lt;- (5 &gt; 2) # Evaluates to TRUE\n\nmy_logical\n\n[1] TRUE\n\nis_greater\n\n[1] TRUE\n\n\n\n\nFactor\nFactors are used to represent categorical data. They are especially useful for representing groups or levels (e.g., “Low”, “Medium”, “High”).\n\nmy_factor &lt;- factor(c(\"Low\", \"Medium\", \"High\", \"Low\", \"Medium\"))\n\nmy_factor\n\n[1] Low    Medium High   Low    Medium\nLevels: High Low Medium\n\n\n\n\nDate and POSIXct\nDate and POSIXct represent dates and date-times, respectively. They are crucial for time series analysis or any analysis that involves dates.\n\nmy_date     &lt;- as.Date(\"2024-01-01\")\nmy_datetime &lt;- as.POSIXct(\"2024-01-01 12:00:00\")\n\nmy_date\n\n[1] \"2024-01-01\"\n\nmy_datetime\n\n[1] \"2024-01-01 12:00:00 EST\"\n\n\n\n\nData Frame and Tibble\nA data frame is a table-like structure that can hold columns of different data types. A tibble is a modern take on the data frame, part of the tidyverse, designed to be more user-friendly. We will discuss more about this is the data cleaning section.\n\nmy_data_frame &lt;- data.frame(\n  id = 1:3,\n  name = c(\"Emma\", \"Rony\", \"Jostin\"),\n  score = c(90, 85, 88)\n)\n\nmy_tibble &lt;- tibble(\n  id = 1:3,\n  name = c(\"Emma\", \"Rony\", \"Jostin\"),\n  score = c(90, 85, 88)\n)\n\n\n\nList\nLists in R can contain elements of different types, including numbers, strings, vectors, and even other lists.\n\nmy_list &lt;- list(name = \"Eric Taylor\", scores = c(90, 85, 88), passed = TRUE)\n\nEach type has its specific purpose and a set of functions that operate on it, making it essential to choose the right type for your data analysis tasks."
  },
  {
    "objectID": "content/01-basics.html#getting-help",
    "href": "content/01-basics.html#getting-help",
    "title": "Introduction to R: The Basics",
    "section": "Getting Help",
    "text": "Getting Help\nIf you don’t understand a function, you can use the question mark and the function you would like to know more about, like this:\n\n?mutate()"
  },
  {
    "objectID": "content/03-data-cleaning-part-ii.html",
    "href": "content/03-data-cleaning-part-ii.html",
    "title": "Data Cleaning and Analysis with tidyverse: Second Part",
    "section": "",
    "text": "In this tutorial, we delve into advanced data cleaning and analysis techniques focusing on student and department datasets. We will also demonstrate how to create custom functions in R to automate repetitive tasks in data analysis.\n\n\nWe will start by merging datasets using dplyr’s join functions to combine student information with department details.\n\n\n\n# Students data\nstudents &lt;- tibble(\n  stu_id = c(1, 2, 3, 4),\n  stu_name = c(\"Emma\", \"Rony\", \"Jostin\", \"David\"),\n  dept_id = c(2, 2, 3, 4)\n)\n\n# Departments data\ndepartments &lt;- tibble(\n  dept_id = c(1, 2, 3, 4),\n  dept_name = c(\"Math\", \"EDU\", \"Science\", \"ECON\")\n)\n\n\n\n\n\n# Include all students and their departments if available\nstu_dept &lt;- left_join(students, departments, by = \"dept_id\")\nstu_dept\n\n# A tibble: 4 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n\n\n\n\n\n\n# Include all departments and any students in those departments\ndept_stu &lt;- right_join(students, departments, by = \"dept_id\")\ndept_stu\n\n# A tibble: 5 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n5     NA &lt;NA&gt;           1 Math     \n\n\n\n\n\n\n# Include all students and all departments, matching where possible\nall_stu_dept &lt;- full_join(students, departments, by = \"dept_id\")\nall_stu_dept\n\n# A tibble: 5 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n5     NA &lt;NA&gt;           1 Math     \n\n\n\n\n\n\nCreating custom functions can significantly enhance efficiency in data analysis. It might not be the case, but if you want to have a function that estimates the mean, sd, and std value in a column we can do the following. Let’s called it add_stats_columns. This function is designed to enhance a dataset by adding statistical analysis columns related to a specific numeric column within the dataset. It calculates the mean, standard deviation, and creates a standardized version of the selected column. Below is an explanation of the function and a breakdown of each line within it:\n\n\n\nadd_stats_columns &lt;- function(data, column_name) {\n  mean_val &lt;- mean(data[[column_name]], na.rm = TRUE)\n  sd_val   &lt;- sd(data[[column_name]], na.rm = TRUE)\n  \n  data[[paste0(column_name, \"_mean\")]] &lt;- mean_val\n  data[[paste0(column_name, \"_sd\")]]   &lt;- sd_val\n  data[[paste0(column_name, \"_standardized\")]] &lt;- (data[[column_name]] - mean_val) / sd_val\n  \n  return(data)\n}\n\n\n\n\nadd_stats_columns &lt;- function(data, column_name) { ... }: This line defines the function add_stats_columns that takes two arguments: data, a dataset (in the form of a data frame or tibble), and column_name, a string representing the name of the column to be analyzed.\nmean_val &lt;- mean(data[[column_name]], na.rm = TRUE): This line calculates the mean of the specified column, excluding any NA (missing) values with na.rm = TRUE, and stores it in mean_val.\nsd_val &lt;- sd(data[[column_name]], na.rm = TRUE): Similarly, this line calculates the standard deviation of the specified column, excluding NA values, and stores it in sd_val.\ndata[[paste0(column_name, \"_mean\")]] &lt;- mean_val: This line creates a new column in the dataset named after the original column with _mean appended (e.g., if column_name is \"scores\", the new column name will be \"scores_mean\"), and assigns the calculated mean value to this new column for all rows.\ndata[[paste0(column_name, \"_sd\")]] &lt;- sd_val: This line adds another new column to the dataset for the standard deviation, following the same naming convention as for the mean (e.g., \"scores_sd\"), and fills it with the calculated standard deviation value.\ndata[[paste0(column_name, \"_standardized\")]] &lt;- (data[[column_name]] - mean_val) / sd_val: This line calculates the standardized value for each row in the specified column by subtracting the mean and dividing by the standard deviation. It then stores these values in a new column named with _standardized appended to the original column name (e.g., \"scores_standardized\"). Standardizing a dataset in this way adjusts the values to have a mean of 0 and a standard deviation of 1, which is useful for certain types of analysis and modeling.\nreturn(data): Finally, the function returns the modified dataset with the new statistical columns added. In fact, you can just write data, do not need to use the return function but let’s keep it.\n\n\n\n\n\nAssuming students is a dataset with a numeric column named \"math_scores\", you can use the function to add statistical analysis columns related to \"math_scores\" as follows:\n\n# Example usage with a hypothetical numeric column in students dataset\n# Let's merge a math_scores data first.\nscores &lt;- tibble(\n  stu_id = c(1, 2, 3, 4),\n  math_scores = c(80, 95, 93, 90)\n)\n\n# Merge the scores with the students data using stu_id \nstu_scores &lt;- right_join(students, scores, by = \"stu_id\")\nstu_scores\n\n# A tibble: 4 × 4\n  stu_id stu_name dept_id math_scores\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1      1 Emma           2          80\n2      2 Rony           2          95\n3      3 Jostin         3          93\n4      4 David          4          90\n\n# Now, let's apply the function add_stats_columns\nstu_scores_with_stats &lt;- add_stats_columns(stu_scores, \"math_scores\")\nstu_scores_with_stats\n\n# A tibble: 4 × 7\n  stu_id stu_name dept_id math_scores math_scores_mean math_scores_sd\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1      1 Emma           2          80             89.5           6.66\n2      2 Rony           2          95             89.5           6.66\n3      3 Jostin         3          93             89.5           6.66\n4      4 David          4          90             89.5           6.66\n# ℹ 1 more variable: math_scores_standardized &lt;dbl&gt;\n\n\n\n\n\nUsing dplyr and purrr to apply functions to each group separately.\n\n# Group by department and apply stats function\nstudents_grouped &lt;- stu_scores %&gt;%\n  group_by(dept_id) %&gt;%\n  group_modify(~ add_stats_columns(.x, \"math_scores\")) %&gt;%\n  ungroup()\n\nstudents_grouped\n\n# A tibble: 4 × 7\n  dept_id stu_id stu_name math_scores math_scores_mean math_scores_sd\n    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1       2      1 Emma              80             87.5           10.6\n2       2      2 Rony              95             87.5           10.6\n3       3      3 Jostin            93             93             NA  \n4       4      4 David             90             90             NA  \n# ℹ 1 more variable: math_scores_standardized &lt;dbl&gt;\n\n\ngroup_modify() applies a function to each group of a grouped dataframe, where .x is the sliced dataframe for each group. This way, the add_stats_columns function is applied correctly to each department group within your stu_scores dataset.\nThis corrected approach ensures that your custom function add_stats_columns is applied to the math_scores column for each group defined by dept_id, achieving the intended goal of adding statistical columns based on department groups."
  },
  {
    "objectID": "content/03-data-cleaning-part-ii.html#merging-datasets",
    "href": "content/03-data-cleaning-part-ii.html#merging-datasets",
    "title": "Data Cleaning and Analysis with tidyverse: Second Part",
    "section": "",
    "text": "We will start by merging datasets using dplyr’s join functions to combine student information with department details.\n\n\n\n# Students data\nstudents &lt;- tibble(\n  stu_id = c(1, 2, 3, 4),\n  stu_name = c(\"Emma\", \"Rony\", \"Jostin\", \"David\"),\n  dept_id = c(2, 2, 3, 4)\n)\n\n# Departments data\ndepartments &lt;- tibble(\n  dept_id = c(1, 2, 3, 4),\n  dept_name = c(\"Math\", \"EDU\", \"Science\", \"ECON\")\n)\n\n\n\n\n\n# Include all students and their departments if available\nstu_dept &lt;- left_join(students, departments, by = \"dept_id\")\nstu_dept\n\n# A tibble: 4 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n\n\n\n\n\n\n# Include all departments and any students in those departments\ndept_stu &lt;- right_join(students, departments, by = \"dept_id\")\ndept_stu\n\n# A tibble: 5 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n5     NA &lt;NA&gt;           1 Math     \n\n\n\n\n\n\n# Include all students and all departments, matching where possible\nall_stu_dept &lt;- full_join(students, departments, by = \"dept_id\")\nall_stu_dept\n\n# A tibble: 5 × 4\n  stu_id stu_name dept_id dept_name\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;    \n1      1 Emma           2 EDU      \n2      2 Rony           2 EDU      \n3      3 Jostin         3 Science  \n4      4 David          4 ECON     \n5     NA &lt;NA&gt;           1 Math"
  },
  {
    "objectID": "content/03-data-cleaning-part-ii.html#creating-functions-for-data-analysis",
    "href": "content/03-data-cleaning-part-ii.html#creating-functions-for-data-analysis",
    "title": "Data Cleaning and Analysis with tidyverse: Second Part",
    "section": "",
    "text": "Creating custom functions can significantly enhance efficiency in data analysis. It might not be the case, but if you want to have a function that estimates the mean, sd, and std value in a column we can do the following. Let’s called it add_stats_columns. This function is designed to enhance a dataset by adding statistical analysis columns related to a specific numeric column within the dataset. It calculates the mean, standard deviation, and creates a standardized version of the selected column. Below is an explanation of the function and a breakdown of each line within it:\n\n\n\nadd_stats_columns &lt;- function(data, column_name) {\n  mean_val &lt;- mean(data[[column_name]], na.rm = TRUE)\n  sd_val   &lt;- sd(data[[column_name]], na.rm = TRUE)\n  \n  data[[paste0(column_name, \"_mean\")]] &lt;- mean_val\n  data[[paste0(column_name, \"_sd\")]]   &lt;- sd_val\n  data[[paste0(column_name, \"_standardized\")]] &lt;- (data[[column_name]] - mean_val) / sd_val\n  \n  return(data)\n}\n\n\n\n\nadd_stats_columns &lt;- function(data, column_name) { ... }: This line defines the function add_stats_columns that takes two arguments: data, a dataset (in the form of a data frame or tibble), and column_name, a string representing the name of the column to be analyzed.\nmean_val &lt;- mean(data[[column_name]], na.rm = TRUE): This line calculates the mean of the specified column, excluding any NA (missing) values with na.rm = TRUE, and stores it in mean_val.\nsd_val &lt;- sd(data[[column_name]], na.rm = TRUE): Similarly, this line calculates the standard deviation of the specified column, excluding NA values, and stores it in sd_val.\ndata[[paste0(column_name, \"_mean\")]] &lt;- mean_val: This line creates a new column in the dataset named after the original column with _mean appended (e.g., if column_name is \"scores\", the new column name will be \"scores_mean\"), and assigns the calculated mean value to this new column for all rows.\ndata[[paste0(column_name, \"_sd\")]] &lt;- sd_val: This line adds another new column to the dataset for the standard deviation, following the same naming convention as for the mean (e.g., \"scores_sd\"), and fills it with the calculated standard deviation value.\ndata[[paste0(column_name, \"_standardized\")]] &lt;- (data[[column_name]] - mean_val) / sd_val: This line calculates the standardized value for each row in the specified column by subtracting the mean and dividing by the standard deviation. It then stores these values in a new column named with _standardized appended to the original column name (e.g., \"scores_standardized\"). Standardizing a dataset in this way adjusts the values to have a mean of 0 and a standard deviation of 1, which is useful for certain types of analysis and modeling.\nreturn(data): Finally, the function returns the modified dataset with the new statistical columns added. In fact, you can just write data, do not need to use the return function but let’s keep it.\n\n\n\n\n\nAssuming students is a dataset with a numeric column named \"math_scores\", you can use the function to add statistical analysis columns related to \"math_scores\" as follows:\n\n# Example usage with a hypothetical numeric column in students dataset\n# Let's merge a math_scores data first.\nscores &lt;- tibble(\n  stu_id = c(1, 2, 3, 4),\n  math_scores = c(80, 95, 93, 90)\n)\n\n# Merge the scores with the students data using stu_id \nstu_scores &lt;- right_join(students, scores, by = \"stu_id\")\nstu_scores\n\n# A tibble: 4 × 4\n  stu_id stu_name dept_id math_scores\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n1      1 Emma           2          80\n2      2 Rony           2          95\n3      3 Jostin         3          93\n4      4 David          4          90\n\n# Now, let's apply the function add_stats_columns\nstu_scores_with_stats &lt;- add_stats_columns(stu_scores, \"math_scores\")\nstu_scores_with_stats\n\n# A tibble: 4 × 7\n  stu_id stu_name dept_id math_scores math_scores_mean math_scores_sd\n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1      1 Emma           2          80             89.5           6.66\n2      2 Rony           2          95             89.5           6.66\n3      3 Jostin         3          93             89.5           6.66\n4      4 David          4          90             89.5           6.66\n# ℹ 1 more variable: math_scores_standardized &lt;dbl&gt;\n\n\n\n\n\nUsing dplyr and purrr to apply functions to each group separately.\n\n# Group by department and apply stats function\nstudents_grouped &lt;- stu_scores %&gt;%\n  group_by(dept_id) %&gt;%\n  group_modify(~ add_stats_columns(.x, \"math_scores\")) %&gt;%\n  ungroup()\n\nstudents_grouped\n\n# A tibble: 4 × 7\n  dept_id stu_id stu_name math_scores math_scores_mean math_scores_sd\n    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n1       2      1 Emma              80             87.5           10.6\n2       2      2 Rony              95             87.5           10.6\n3       3      3 Jostin            93             93             NA  \n4       4      4 David             90             90             NA  \n# ℹ 1 more variable: math_scores_standardized &lt;dbl&gt;\n\n\ngroup_modify() applies a function to each group of a grouped dataframe, where .x is the sliced dataframe for each group. This way, the add_stats_columns function is applied correctly to each department group within your stu_scores dataset.\nThis corrected approach ensures that your custom function add_stats_columns is applied to the math_scores column for each group defined by dept_id, achieving the intended goal of adding statistical columns based on department groups."
  }
]